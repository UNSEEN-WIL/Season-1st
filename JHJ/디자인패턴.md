## 플라이웨이트 패턴

기존 엔진 등의 경우 **같은 리소스가 있을 때 어떻게 처리할까** 하는 의문이 있었습니다. 이와 관련되어 인터넷을 뒤지다 발견한 패턴으로 아주 간단한 아이디어 입니다.

### 해결하기 위한 문제점
- 만일 파티클을 한 곳에서 사용을 합니다.
- 그런데 위 같은 파티클을 여러 곳에서 참조를 해서 사용합니다.
- 파티클의 여러 복제가 생기면서 메모리가 가득 차게 됩니다.

위와 같은 상황에서 *어차피 같은 파티클*이라면 굳이 복제를 할 필요가 없는 것입니다.


### 해결점 - 공통을 뽑아 공유해서 사용한다
위에서 '같은 파티클'을 '공유 자원'에 두고 사용을 하는 것입니다.
![](https://refactoring.guru/images/patterns/diagrams/flyweight/solution3-ko.png?id=518a4d27e38553f19e02adf737daec12)

이런 식으로 공통되는 자원들을 모두가 공유하는 것입니다. 파티클의 색상과 스프라이트는 고유한 것이니 이는 따로 빼 두는 것이죠. 이제 여기서 각자의 고유한 것들만 두는 객체를 `플라이웨이트` 라고 합니다.

여기서 공유되는 자원들을 컨테이너 객체 등에 올리게 되는데 이외에 별도의 클래스를 두고 관리할 수도 있습니다. 이에 대한 클래스가 많아질 수는 있어도 같은 데이터가 여러군데 복사되는 일은 없을 것입니다.

주의할 점이라고 하면 공유되는 자원들은 수정을 하면 안되기에 public이나 다른 setter를 두는 것에 대해 주의해야 합니다.


## 메멘토 패턴

윈도우의 Ctrl + Z 기능은 어떻게 만들어질까 찾아보다가 발견하게 된 패턴입니다. 만일 되돌리기를 지원하겠다고 한다면 이에 대한 정보를 계속 수집하고 있어야 하며 그 외 되돌린 상태를 대입해줘야 할 기능이 필요합니다.

이런 경우 클래스의 변수들을 public으로 하자니 캡슐화를 깨게 되고 그걸 하지 않자니 기능 구현이 어려울거 같은 문제가 생기게 됩니다.

### 해결책
![](https://refactoring.guru/images/patterns/diagrams/memento/solution-ko.png?id=2311280692fa69436c28b98667f3bcd1)

이것 역시 해결책은 간단합니다. **스냅샷의 생성**은 기존 객체인 `Originator`에게 위임합니다. 이를 통해 외부 객체들이 생성하는 대신 본인이 스스로 생성을 하는 것이죠.

이후 `메멘토`라는 특수 객체에 스냅샷을 저장하라고 합니다. 이 메멘토는 메멘토를 생성한 객체만 접근할 수 있도록 합니다. 동시에 오리지네이터는 이 메멘토들에 대한 접근 권한이 있기에 메멘토 객체를 받아 `Restore`작업을 거칠 수 있게 합니다.

즉 결론적으로는 외부에서 스냅샷을 생성하고 복구하기 보다는 오리지네이터에 해당 인터페이스를 두고 사용하자는 뜻입니다. 이를 통해 필드, 게터, 세터에 직접 접근해 캡슐화를 깨는 것에 대해서 막을 수 있게 됩니다. 

단 단점으로는 메멘토가 많아지는 경우 메모리에 부담이 많이 간다는 것이 있겠죠.

## 참고 자료

https://refactoring.guru/ko/design-patterns/flyweight

https://refactoring.guru/ko/design-patterns/memento